#!/usr/bin/env python3
"""
Detailed walkthrough of a sample retirement simulation showing all tracked data.
This demonstrates what happens year-by-year in the simulation.
"""

import numpy as np
import pandas as pd
from finsim.portfolio_simulation import simulate_portfolio

# Sample parameters for a retiree
params = {
    'n_simulations': 1,  # Single simulation for clarity
    'n_years': 5,  # Just 5 years to show detail
    'initial_portfolio': 1_000_000,
    'current_age': 65,
    'retirement_age': 65,  # Already retired
    
    # Income sources
    'social_security': 30_000,
    'pension': 10_000,
    'employment_income': 0,  # Retired
    
    # Spending
    'annual_consumption': 60_000,
    
    # Market assumptions
    'expected_return': 7.0,  # 7% expected return
    'return_volatility': 15.0,  # 15% volatility
    'dividend_yield': 2.0,  # 2% dividends
    
    # Other parameters
    'state': 'CA',
    'include_mortality': False,  # Turn off for clarity
    'has_annuity': False,
    'annuity_type': 'Life Only',
    'annuity_annual': 0,
    'annuity_guarantee_years': 0,
    'has_spouse': False,
}

print("RETIREMENT PORTFOLIO SIMULATION WALKTHROUGH")
print("=" * 80)
print("\nInitial Setup:")
print(f"  Portfolio: ${params['initial_portfolio']:,.0f}")
print(f"  Age: {params['current_age']}")
print(f"  Social Security: ${params['social_security']:,.0f}/year")
print(f"  Pension: ${params['pension']:,.0f}/year")
print(f"  Consumption Need: ${params['annual_consumption']:,.0f}/year")
print(f"  Expected Return: {params['expected_return']}%")
print(f"  Dividend Yield: {params['dividend_yield']}%")
print()

# Run simulation
np.random.seed(42)  # For reproducibility
results = simulate_portfolio(**params)

# Extract all tracked data (showing what columns we hold onto)
print("DATA TRACKED IN SIMULATION:")
print("-" * 80)
print("\nArrays returned (all dimensions are [n_simulations, n_years+1] or [n_simulations, n_years]):")
for key in results.keys():
    shape = results[key].shape if hasattr(results[key], 'shape') else 'scalar'
    print(f"  {key:20s}: {shape}")
print()

# Create detailed year-by-year breakdown
print("YEAR-BY-YEAR BREAKDOWN:")
print("=" * 80)

# For this single simulation, extract the values
sim_idx = 0  # First (and only) simulation

# Get inflation and COLA factors (these would be calculated internally)
from finsim.cola import get_ssa_cola_factors, get_consumption_inflation_factors

START_YEAR = 2025
cola_factors = get_ssa_cola_factors(START_YEAR, params['n_years'])
inflation_factors = get_consumption_inflation_factors(START_YEAR, params['n_years'])

# Track running cost basis (starts at initial portfolio)
running_cost_basis = params['initial_portfolio']

for year in range(params['n_years']):
    print(f"\nYEAR {year + 1} (Age {params['current_age'] + year + 1}):")
    print("-" * 40)
    
    # Starting position
    start_portfolio = results['portfolio_paths'][sim_idx, year]
    print(f"  Starting Portfolio:     ${start_portfolio:,.0f}")
    print(f"  Cost Basis:            ${running_cost_basis:,.0f}")
    
    # Market growth (implicit in the simulation)
    # This would be from the growth_factors_matrix generated by ReturnGenerator
    end_portfolio_pre_withdrawal = results['portfolio_paths'][sim_idx, year + 1] + results['gross_withdrawals'][sim_idx, year]
    implied_return = (end_portfolio_pre_withdrawal / start_portfolio - 1) if start_portfolio > 0 else 0
    print(f"  Market Return:         {implied_return:.1%}")
    
    # Income streams
    print(f"\n  Income Streams:")
    
    # Social Security with COLA
    ss_with_cola = params['social_security'] * cola_factors[year]
    print(f"    Social Security:     ${ss_with_cola:,.0f} (COLA factor: {cola_factors[year]:.3f})")
    
    # Pension (no COLA)
    print(f"    Pension:            ${params['pension']:,.0f}")
    
    # Dividends
    dividends = results['dividend_income'][sim_idx, year]
    print(f"    Dividends:          ${dividends:,.0f} ({params['dividend_yield']}% of ${start_portfolio:,.0f})")
    
    # Annuity income
    annuity = results['annuity_income'][sim_idx, year]
    if annuity > 0:
        print(f"    Annuity:            ${annuity:,.0f}")
    
    total_income = ss_with_cola + params['pension'] + dividends + annuity
    print(f"    Total Income:       ${total_income:,.0f}")
    
    # Consumption need (inflation-adjusted)
    inflated_consumption = params['annual_consumption'] * inflation_factors[year]
    print(f"\n  Consumption Need:      ${inflated_consumption:,.0f} (inflation factor: {inflation_factors[year]:.3f})")
    
    # Tax liability from PREVIOUS year (paid THIS year)
    if year > 0:
        taxes_to_pay = results['taxes_paid'][sim_idx, year]
        print(f"  Prior Year Taxes Due:  ${taxes_to_pay:,.0f}")
    else:
        taxes_to_pay = 0
        print(f"  Prior Year Taxes Due:  $0 (first year)")
    
    # Withdrawal calculation
    total_need = inflated_consumption + taxes_to_pay
    shortfall = max(0, total_need - total_income)
    print(f"\n  Withdrawal Needed:     ${shortfall:,.0f}")
    print(f"    (${total_need:,.0f} needed - ${total_income:,.0f} income)")
    
    # Capital gains on withdrawal
    if shortfall > 0 and start_portfolio > 0:
        gain_fraction = max(0, (start_portfolio - running_cost_basis) / start_portfolio)
        realized_gains = results['capital_gains'][sim_idx, year]
        print(f"  Capital Gains:         ${realized_gains:,.0f} ({gain_fraction:.1%} of withdrawal)")
        
        # Update cost basis
        withdrawal_fraction = shortfall / start_portfolio if start_portfolio > 0 else 0
        running_cost_basis *= (1 - withdrawal_fraction)
    else:
        realized_gains = 0
    
    # Tax calculation for THIS year (to be paid NEXT year)
    taxes_owed = results['taxes_owed'][sim_idx, year]
    print(f"\n  Taxes on This Year:")
    print(f"    Taxable Income Components:")
    print(f"      Social Security:   ${ss_with_cola + params['pension']:,.0f}")
    print(f"      Capital Gains:    ${realized_gains:,.0f}")
    print(f"      Dividends:        ${dividends:,.0f}")
    print(f"    Total Tax Owed:     ${taxes_owed:,.0f} (to be paid next year)")
    
    # Ending portfolio
    end_portfolio = results['portfolio_paths'][sim_idx, year + 1]
    print(f"\n  Ending Portfolio:      ${end_portfolio:,.0f}")
    
    # Check for failure
    if end_portfolio <= 0:
        print(f"\n  *** PORTFOLIO DEPLETED ***")
        break

print("\n" + "=" * 80)
print("SUMMARY OF TRACKED DATA:")
print("-" * 80)

# Create a DataFrame for easier viewing
df_data = {
    'Year': list(range(1, params['n_years'] + 1)),
    'Age': [params['current_age'] + i + 1 for i in range(params['n_years'])],
    'Starting_Portfolio': results['portfolio_paths'][sim_idx, :-1],
    'Dividend_Income': results['dividend_income'][sim_idx, :],
    'Capital_Gains': results['capital_gains'][sim_idx, :],
    'Gross_Withdrawal': results['gross_withdrawals'][sim_idx, :],
    'Taxes_Owed': results['taxes_owed'][sim_idx, :],
    'Taxes_Paid': results['taxes_paid'][sim_idx, :],
    'Net_Withdrawal': results['net_withdrawals'][sim_idx, :],
    'Ending_Portfolio': results['portfolio_paths'][sim_idx, 1:],
}

df = pd.DataFrame(df_data)
pd.set_option('display.float_format', '{:,.0f}'.format)
print("\n", df.to_string(index=False))

print("\n" + "=" * 80)
print("KEY INSIGHTS:")
print("-" * 80)
print("""
1. FULL DATASET TRACKED: We maintain complete arrays for:
   - Portfolio values at each year boundary
   - All income components (dividends, capital gains, annuities)
   - All withdrawal amounts (gross and net)
   - Tax liabilities (both owed and paid)
   - Mortality status for each simulation
   - Cost basis tracking for accurate capital gains

2. TAX TIMING: Taxes are calculated on current year income but paid next year
   - This creates a one-year lag in tax payments
   - Final year's taxes may not be paid if portfolio depletes

3. INFLATION ADJUSTMENTS:
   - Social Security uses actual SSA COLA projections (CPI-W based)
   - Consumption uses C-CPI-U inflation projections
   - These are different indices with different adjustment rates

4. CAPITAL GAINS TRACKING:
   - We maintain cost basis throughout the simulation
   - Only the gain portion of withdrawals is taxable
   - Cost basis reduces proportionally with withdrawals

5. MONTE CARLO ASPECTS (when n_simulations > 1):
   - Each simulation gets different market returns
   - Mortality is randomly determined based on SSA tables
   - All paths are tracked independently
""")